# TV Screener+ Progress Log

This file tracks learnings, decisions, and important notes from each completed task.
It serves as institutional knowledge for anyone continuing work on this codebase.

Last Updated: January 2025

---

## How to Read This File

- Entries are appended chronologically (newest at bottom)
- Each entry includes: Task ID, Date, Key Learnings
- Search for specific topics using Ctrl+F
- Critical warnings marked with [!]

---

## Project Setup

### Initial Planning (January 2025)

**Decisions Made:**
- Architecture: Python (FastAPI) + TypeScript (Fastify/React) hybrid
- Database: SQLite with better-sqlite3 (added in Phase B, not MVP)
- MVP approach: In-memory first, persistence later
- Development: Direct (no Docker), hot-reload enabled

**Key Documents (in `docs/`):**
- `spec_v2.md` - Full specification with all requirements
- `tv-screener-implementation-plan.md` - Sprint-by-sprint implementation plan
- `progress.txt` - This file (append-only learning log)
- `planner.md` - Planning agent template (reference)

**Workflow:**
- PLAN MODE: Discuss approach before coding
- BUILD MODE: Implement after agreement
- Tests written per task

---

## Sprint Progress

(Entries will be appended below as tasks are completed)

---

### Task 1.1: Initialize Project Structure
**Date:** January 2025
**Status:** Completed

**What was done:**
- Created monorepo folder structure: `screener-service/`, `app/`, `docs/`
- Moved all spec/planning files to `docs/` folder
- Created `AGENTS.md` at root with instructions for AI agents
- Created `.gitignore` for Python + Node.js artifacts

**Key Learnings:**
- Keep documentation centralized in `docs/` for easy discovery
- `AGENTS.md` ensures any AI agent reads specs before making changes
- Empty placeholder files (`__init__.py`, `requirements.txt`, `package.json`) help establish structure

**File Locations:**
- Specs and plans: `docs/`
- Python service: `screener-service/src/`
- TypeScript backend: `app/src/server/`
- React frontend: `app/src/client/`

---

### Task 1.2: Implement Python Health Endpoint
**Date:** January 2025
**Status:** Completed

**What was done:**
- Set up devenv at project root (Python 3.11 + Node 20)
- Created FastAPI application with health endpoint
- Added pytest tests for health endpoint

**Files Created:**
- `devenv.nix` - Nix-based dev environment (Python + Node)
- `devenv.yaml` - devenv configuration
- `.envrc` - direnv auto-activation
- `screener-service/src/config.py` - Settings with pydantic-settings
- `screener-service/src/main.py` - FastAPI app entry point
- `screener-service/src/routes.py` - /health endpoint
- `screener-service/tests/test_health.py` - Endpoint tests
- `screener-service/pytest.ini` - Pytest configuration

**Key Learnings:**
- devenv.nix at project root provides unified dev environment for Python + Node
- Use `pydantic-settings` for type-safe configuration from env vars
- FastAPI test client uses `httpx.AsyncClient` with `ASGITransport`
- [!] Remember to add `sys.path` manipulation in tests to import from `src/`

**How to Run:**
```bash
# Enter devenv shell (auto-activates with direnv)
devenv shell

# Or manually:
cd screener-service
pip install -r requirements.txt
python src/main.py

# Run tests:
cd screener-service
pytest
```

**Endpoints:**
- `GET /health` - Returns `{"status": "ok", "timestamp": "..."}`

---

### Task 1.3: Implement /scan Endpoint with tradingview-screener
**Date:** January 2025
**Status:** Completed

**What was done:**
- Created Pydantic models for scan request/response schemas
- Implemented ScreenerService wrapper for tradingview-screener library
- Added /scan endpoint with filter, ordering, pagination support
- Created comprehensive tests with real TradingView API calls

**Files Created/Modified:**
- `screener-service/src/models.py` - Request/response Pydantic models
- `screener-service/src/screener.py` - tradingview-screener wrapper
- `screener-service/src/routes.py` - Added /scan endpoint
- `screener-service/tests/test_scan.py` - Scan endpoint tests (8 tests)
- `screener-service/requirements.txt` - Added tradingview-screener dependency

**Key Learnings:**
- [!] tradingview-screener Column class uses Python comparison operators, NOT methods:
  - CORRECT: `col > value`, `col >= value`, `col == value`
  - WRONG: `col.above(value)`, `col.below(value)`, `col.equal(value)`

- [!] Multiple filters MUST use `where2(And(...))`, NOT chained `.where()` calls:
  - CORRECT: `query.where2(And(condition1, condition2, condition3))`
  - WRONG: `query.where(cond1).where(cond2).where(cond3)` (only applies last filter!)

- Single filter can use `query.where(condition)` directly

- Column methods available: `.between(low, high)`, `.not_between()`, `.isin([])`, `.not_in([])`

- Response fields use aliases for camelCase JSON (e.g., `total_count` → `totalCount`)

**Filter Operators Supported:**
- Comparison: `gt`, `gte`, `lt`, `lte`, `eq`, `neq`
- Range: `between`, `not_between` (require list of 2 values)
- Set: `in`, `not_in` (require list of values)

**Endpoints:**
- `POST /scan` - Execute screener scan
  - Request: `{columns: [...], filters?: [...], orderBy?: {...}, limit?: 50, offset?: 0}`
  - Response: `{totalCount, results, timestamp, durationMs}`

**Tests (8 total, all passing):**
1. `test_scan_basic_columns` - Basic column selection
2. `test_scan_with_filter_gt` - Greater-than filter
3. `test_scan_with_filter_between` - Between filter
4. `test_scan_with_ordering` - Order by field
5. `test_scan_with_multiple_filters` - Multiple filters combined
6. `test_scan_empty_columns_rejected` - Validation error on empty columns
7. `test_scan_invalid_between_value` - Validation error on bad between value
8. `test_scan_response_timing` - Response includes timing metadata

---

### Sprint 2: TypeScript Backend Setup
**Date:** January 2025
**Status:** Completed

---

### Task 2.1: Initialize TypeScript/Fastify Project
**Date:** January 2025
**Status:** Completed

**What was done:**
- Set up Node.js project with TypeScript, Fastify, and strict type checking
- Created Fastify server with CORS for local development
- Added health endpoint at /api/health

**Files Created:**
- `app/package.json` - Project dependencies (fastify, @fastify/cors, tsx, vitest)
- `app/tsconfig.json` - Strict TypeScript configuration
- `app/tsconfig.server.json` - Server-specific build config
- `app/vitest.config.ts` - Vitest test configuration
- `app/src/server/index.ts` - Fastify server entry point
- `app/src/server/config.ts` - Configuration from environment variables
- `app/tests/health.test.ts` - Health endpoint tests

**Key Learnings:**
- [!] With `noPropertyAccessFromIndexSignature`, must use bracket notation for process.env:
  - CORRECT: `process.env["APP_PORT"]`
  - WRONG: `process.env.APP_PORT`

- Strict TypeScript settings enabled:
  - `noImplicitAny`, `strictNullChecks`, `strictFunctionTypes`
  - `noUnusedLocals`, `noUnusedParameters`
  - `exactOptionalPropertyTypes`, `noImplicitReturns`
  - `noUncheckedIndexedAccess`, `noPropertyAccessFromIndexSignature`

- tsx (via `tsx watch`) provides fast TypeScript execution without compilation step

**How to Run:**
```bash
cd app
npm install
npm run dev:server  # Starts on port 3000
npm test            # Run tests
```

---

### Task 2.2: Create Screener Client Service
**Date:** January 2025
**Status:** Completed

**What was done:**
- Created TypeScript types matching Python API models
- Implemented ScreenerClient class using ofetch for HTTP calls
- Added custom ScreenerServiceError for proper error handling

**Files Created:**
- `app/src/server/types/screener.ts` - TypeScript types for API
- `app/src/server/services/screenerClient.ts` - HTTP client for Python service
- `app/tests/screenerClient.test.ts` - Client integration tests (6 tests)

**Key Learnings:**
- ofetch provides clean async HTTP with automatic JSON parsing
- Custom error class (ScreenerServiceError) preserves HTTP status codes and details
- Type assertions needed for indexed access with `noUncheckedIndexedAccess`

**TypeScript Types:**
```typescript
interface ScanRequest {
  markets?: string[];
  columns: string[];
  filters?: Filter[];
  orderBy?: OrderBy;
  limit?: number;
  offset?: number;
}

interface ScanResponse {
  totalCount: number;
  results: Record<string, unknown>[];
  timestamp: string;
  durationMs: number;
}
```

---

### Task 2.3: Create Proxy Routes
**Date:** January 2025
**Status:** Completed

**What was done:**
- Created Fastify routes that proxy to Python service
- Added error handling that forwards Python errors with correct status codes
- Registered routes in main server file

**Files Created/Modified:**
- `app/src/server/routes/screener.ts` - Screener proxy routes
- `app/src/server/index.ts` - Added route registration
- `app/tests/routes.test.ts` - Route integration tests (5 tests)

**Endpoints:**
- `POST /api/scan` - Proxy to Python /scan
- `GET /api/screener/health` - Proxy to Python /health
- `GET /api/health` - Node.js service health (direct)

**Key Learnings:**
- Fastify routes use async/await pattern naturally
- Error responses must explicitly return reply to satisfy type checker
- Integration tests require both Python and Node services running

**Tests (13 total across Sprint 2):**
- health.test.ts: 2 tests (Node health endpoint)
- screenerClient.test.ts: 6 tests (Python API client)
- routes.test.ts: 5 tests (Proxy route integration)

---

### Sprint 3: Basic React UI
**Date:** January 2025
**Status:** Completed

---

### Task 3.1: Initialize React/Vite Project
**Date:** January 2025
**Status:** Completed

**What was done:**
- Set up Vite with React and TypeScript
- Configured Tailwind CSS for styling
- Created basic App component with header and main content
- Added Vite proxy to backend (port 3000)

**Files Created:**
- `app/vite.config.ts` - Vite configuration with proxy
- `app/tailwind.config.js` - Tailwind configuration
- `app/postcss.config.js` - PostCSS configuration
- `app/src/client/index.html` - HTML entry point
- `app/src/client/main.tsx` - React entry point
- `app/src/client/App.tsx` - Main App component
- `app/src/client/styles/index.css` - Tailwind imports
- `app/tests/client/App.test.tsx` - App component tests

**Key Learnings:**
- [!] Must add `"jsx": "react-jsx"` to tsconfig.json for JSX support
- [!] Testing-library needs `cleanup()` in afterEach to prevent duplicate elements
- Vite's root option changes the project root for client files
- Vitest `environmentMatchGlobs` allows different environments per test folder

**How to Run:**
```bash
cd app
npm run dev:client  # Starts Vite on port 5173
npm run dev         # Starts both server and client concurrently
```

---

### Task 3.2: Create TickerInput Component
**Date:** January 2025
**Status:** Completed

**What was done:**
- Created TickerInput component for comma-separated ticker entry
- Implemented input validation and parsing
- Added loading state and disabled states
- Styled with Tailwind CSS

**Files Created:**
- `app/src/client/components/TickerInput.tsx` - Ticker input component
- `app/tests/client/TickerInput.test.tsx` - Component tests (9 tests)

**Key Learnings:**
- Parse tickers: split by comma, trim, uppercase, filter empty
- useCallback for event handlers to prevent unnecessary re-renders
- Show ticker count feedback as user types

**Component Props:**
```typescript
interface TickerInputProps {
  onScan: (tickers: string[]) => void;
  isLoading?: boolean;
}
```

---

### Task 3.3: Create API Client & Connect to Backend
**Date:** January 2025
**Status:** Completed

**What was done:**
- Created frontend API client with typed fetch
- Implemented useScreener hook for scan state management
- Connected TickerInput to API via hook
- Added results table display with formatting

**Files Created:**
- `app/src/client/api/client.ts` - Typed API client
- `app/src/client/hooks/useScreener.ts` - Screener state hook

**Key Learnings:**
- Frontend API client uses native fetch (simpler than ofetch for client)
- useScreener hook manages loading/error/data state
- Format helpers for numbers, percentages, and volumes
- Color coding for positive/negative changes

**Hook Interface:**
```typescript
interface UseScreenerReturn {
  data: ScanResponse | null;
  isLoading: boolean;
  error: string | null;
  executeScan: (tickers: string[], columns?: string[]) => Promise<void>;
  clearError: () => void;
  clearData: () => void;
}
```

**Tests (25 total across all sprints):**
- Server tests: 13 (health, screenerClient, routes)
- Client tests: 12 (App: 3, TickerInput: 9)

---

### Sprint 4: Results Table Display
**Date:** January 2025
**Status:** Completed

---

### Task 4.1: Create Results Table Component
**Date:** January 2025
**Status:** Completed

**What was done:**
- Created ResultsTable component with sortable columns
- Added number formatting (price, volume, market cap)
- Color coding for positive/negative changes
- Empty state handling when no results

**Files Created:**
- `app/src/client/components/ResultsTable.tsx` - Results table component
- `app/tests/client/ResultsTable.test.tsx` - Component tests (18 tests)

**Key Learnings:**
- [!] Use `toSorted()` (ES2023) instead of `sort()` for immutable sorting in React
- [!] Must add `"lib": ["ES2023", "DOM", "DOM.Iterable"]` to tsconfig.json for toSorted()
- Use `useMemo()` for expensive computations like sorting
- Use `memo()` sparingly - only when props change frequently but render is expensive

**Number Formatting:**
```typescript
// Volume: 52000000 → "52.00M"
// Market Cap: 2850000000000 → "$2.85T"
// Change: 2.34 → "+2.34%"
```

---

### Task 4.2: Add Column Sorting
**Date:** January 2025
**Status:** Completed

**What was done:**
- Added sortable headers with click handlers
- Implemented ascending/descending toggle
- Sort indicators (⇅, ↑, ↓) show current sort state
- Null values sort to bottom

**Key Learnings:**
- Store sort state as `{column: string | null, direction: 'asc' | 'desc'}`
- Click cycles: none → desc → asc → desc → ...
- Null handling: treat nulls as smaller than any value

---

### Task 4.3: Add Basic Filters UI
**Date:** January 2025
**Status:** Completed

**What was done:**
- Created BasicFilters component with price/volume inputs
- Added filter-to-API conversion (buildFilters function)
- Clear filters functionality
- Loading state disables inputs
- Integrated with useScreener hook via setFilters

**Files Created:**
- `app/src/client/components/BasicFilters.tsx` - Filter inputs component
- `app/tests/client/BasicFilters.test.tsx` - Component tests (12 tests)

**Files Modified:**
- `app/src/client/hooks/useScreener.ts` - Added setFilters, filtersRef
- `app/src/client/App.tsx` - Integrated BasicFilters component

**Key Learnings:**
- Use `useRef` for values that need to be accessed in callbacks without re-creating them
- `filtersRef.current` allows executeScan to access current filters without re-render
- Clear button only shows when filters have values (conditional render)

**Filter Objects:**
```typescript
// priceMin: "50" → { field: "close", op: "gte", value: 50 }
// priceMax: "100" → { field: "close", op: "lte", value: 100 }
// volumeMin: "1000000" → { field: "volume", op: "gte", value: 1000000 }
```

**Tests (42 client tests total):**
- App.test.tsx: 3 tests
- TickerInput.test.tsx: 9 tests
- ResultsTable.test.tsx: 18 tests
- BasicFilters.test.tsx: 12 tests

---

### Skills Added (Pre-Sprint 4)
**Date:** January 2025

**Skills Installed:**
- `skills/agent-browser/` - Browser automation for visual testing
- `skills/frontend-design/` - Distinctive UI patterns
- `skills/frontend-responsive-ui/` - Mobile-first responsive design
- `skills/react-best-practices/` - React 19/Next.js 15 performance rules (45 rules)
- `skills/read-github-docs/` - GitHub docs via gitmcp.io

**Skills Applied in Sprint 4:**
- **react-best-practices**: Used `toSorted()` for immutable sorting, `useMemo()` for expensive computations
- **frontend-responsive-ui**: Grid layout with responsive breakpoints (sm:grid-cols-2, lg:grid-cols-4)

---

### Sprint 5 Enhancement: Draggable & Resizable Columns
**Date:** January 2025
**Status:** Completed

**What was done:**
- Added drag-to-reorder columns via HTML5 drag-drop API
- Added column resize handles on table headers
- Visual feedback during drag (opacity, blue highlight on drop target)
- Column widths persist during session

**Files Modified:**
- `app/src/client/components/ResultsTable.tsx` - Added drag/resize handlers
- `app/src/client/App.tsx` - Connected onColumnsChange to update state

**Key Learnings:**
- Use `draggable={false}` on resize handles to prevent drag interference
- Resize handles need wider hit area (12px vs 4px) for usability
- `table-fixed` layout required for precise width control

---

## Phase B: Persistence & Core Features

---

### Sprint 6: SQLite Setup & Schema
**Date:** January 2025
**Status:** Completed

---

### Task 6.1: Set Up better-sqlite3
**Date:** January 2025
**Status:** Completed

**What was done:**
- Installed better-sqlite3 and @types/better-sqlite3
- Created database connection singleton with WAL mode
- Added graceful shutdown handling
- Database path configurable via DATABASE_PATH env var

**Files Created:**
- `app/src/server/db/index.ts` - Database connection singleton
- `app/tests/db.test.ts` - Database connection tests (3 tests)

**Files Modified:**
- `app/src/server/config.ts` - Added databasePath config
- `app/src/server/index.ts` - Added database init and shutdown

**Key Learnings:**
- WAL mode (`pragma("journal_mode = WAL")`) enables better concurrency
- Foreign keys must be enabled explicitly: `pragma("foreign_keys = ON")`
- Create parent directories automatically: `mkdirSync(dir, { recursive: true })`

---

### Task 6.2: Create Database Schema
**Date:** January 2025
**Status:** Completed

**What was done:**
- Created full schema matching spec_v2.md (14 tables)
- Implemented simple version-based migration system
- Migrations run automatically on database connection
- Added indexes for common queries

**Files Created:**
- `app/src/server/db/schema.ts` - Schema definitions and migrations
- `app/tests/schema.test.ts` - Schema tests (13 tests)

**Tables Created:**
- `schema_version` - Migration tracking
- `watchlists` - Watchlist metadata
- `watchlist_items` - Tickers in watchlists
- `watchlist_item_tags` - Tags for watchlist items
- `screener_configs` - Saved screener configurations
- `alert_rules` - Alert rule definitions
- `alert_cooldowns` - Per-ticker cooldown tracking
- `momentum_configs` - Momentum scoring configs
- `alert_history` - Alert trigger history
- `user_preferences` - Key-value preferences
- `favorite_fields` - User's favorite fields
- `keyboard_shortcuts` - Custom shortcuts
- `scan_stats` - Scan statistics
- `top_performers` - Frequently appearing tickers

**Key Learnings:**
- SQLite uses TEXT for timestamps (ISO format), not DATETIME type
- JSON stored as TEXT in SQLite, parsed in application layer
- Use `IF NOT EXISTS` for idempotent migrations
- Cascading deletes with `ON DELETE CASCADE`

---

### Task 6.3: Create Base Repository Pattern
**Date:** January 2025
**Status:** Completed

**What was done:**
- Created generic BaseRepository with typed CRUD operations
- Implemented: findById, findAll, findBy, create, update, delete
- Added transaction support with automatic rollback
- Created custom DatabaseError for error handling

**Files Created:**
- `app/src/server/db/repositories/base.ts` - Generic repository
- `app/tests/repositories/base.test.ts` - Repository tests (27 tests)

**Repository Methods:**
```typescript
findById(id): T | undefined
findByIdOrThrow(id): T
findAll(orderBy?, direction?): T[]
findBy(column, value): T[]
findOneBy(column, value): T | undefined
create(data): T
update(id, data): T
delete(id): boolean
deleteOrThrow(id): void
count(): number
exists(id): boolean
transaction(fn): R
```

**Key Learnings:**
- Use TypeScript generics for type-safe repositories
- `Omit<T, "id" | "created_at">` for CreateEntity type
- Wrap errors in DatabaseError with operation context
- Transaction pattern: `db.transaction(fn)()`

**Tests (85 total across Sprint 6 + previous):**
- db.test.ts: 3 tests
- schema.test.ts: 13 tests
- base.test.ts: 27 tests
- Client tests: 42 tests

---

### Sprint 7: Watchlist Backend
**Date:** January 2025
**Status:** Completed

---

### Task 7.1: Watchlist Repository
**Date:** January 2025
**Status:** Completed

**What was done:**
- Extended BaseRepository with watchlist-specific operations
- Implemented CRUD for watchlists, items, and tags
- Added batch operations (addItems) with duplicate handling
- Cascading deletes work via foreign keys

**Files Created:**
- `app/src/server/db/repositories/watchlist.ts` - Watchlist repository
- `app/tests/repositories/watchlist.test.ts` - Repository tests (32 tests)

**Key Methods:**
```typescript
// Watchlists
findByName(name): Watchlist | undefined
findWithItems(id): WatchlistWithItems | undefined
findAllWithCounts(): (Watchlist & { itemCount: number })[]

// Items
getItems(watchlistId): WatchlistItem[]
addItem(watchlistId, ticker, notes?): WatchlistItem
addItems(watchlistId, tickers): { added, skipped }
updateItemNotes(itemId, notes): WatchlistItem
removeItem(watchlistId, ticker): boolean

// Tags
getItemTags(itemId): string[]
setItemTags(itemId, tags): void
getAllTags(): string[]
```

---

### Task 7.2: Watchlist API Routes
**Date:** January 2025
**Status:** Completed

**What was done:**
- Created RESTful API routes for watchlist management
- Proper HTTP status codes (201 created, 204 no content, 404/409 errors)
- Input validation on all endpoints
- Database attached to Fastify app instance

**Files Created:**
- `app/src/server/routes/watchlist.ts` - Watchlist API routes
- `app/tests/watchlistRoutes.test.ts` - Route tests (35 tests)

**Files Modified:**
- `app/src/server/index.ts` - Register watchlist routes

**API Endpoints:**
```
GET    /api/watchlists           - List all watchlists with item counts
POST   /api/watchlists           - Create watchlist
GET    /api/watchlists/:id       - Get watchlist with items and tags
PUT    /api/watchlists/:id       - Update watchlist
DELETE /api/watchlists/:id       - Delete watchlist

POST   /api/watchlists/:id/items       - Add ticker
POST   /api/watchlists/:id/items/batch - Add multiple tickers
PUT    /api/watchlists/:id/items/:itemId - Update item notes/tags
DELETE /api/watchlists/:id/items/:itemId - Remove item

GET    /api/tags                 - Get all unique tags
```

---

### Task 7.3: Watchlist Import/Export
**Date:** January 2025
**Status:** Completed

**What was done:**
- Import endpoint with format auto-detection
- Support for CSV, JSON, plain text, TradingView formats
- Export to CSV or JSON with proper headers
- TradingView format strips exchange prefixes (NASDAQ:AAPL → AAPL)

**Import Formats Supported:**
- **Plain text**: One ticker per line or comma-separated
- **CSV**: With or without header row
- **JSON**: Array or `{tickers: [...]}` or `{items: [{ticker: ...}]}`
- **TradingView**: `NASDAQ:AAPL, NYSE:MSFT` format

**API Endpoints:**
```
POST /api/watchlists/import          - Import tickers to new watchlist
GET  /api/watchlists/:id/export      - Export as CSV (default) or JSON
GET  /api/watchlists/:id/export?format=json
```

**Key Learnings:**
- Auto-detect format: JSON starts with `{`/`[`, TradingView has `:` prefix
- Use `toUpperCase()` consistently for ticker storage
- CSV export: escape quotes with `""`
- Return proper Content-Disposition header for downloads

**Tests (152 total):**
- watchlist.test.ts: 32 tests (repository)
- watchlistRoutes.test.ts: 35 tests (API routes + import/export)

---

---

### Sprint 8: Watchlist Frontend
**Date:** January 2025
**Status:** Completed

---

### Task 8.1-8.3: Watchlist UI Components
**Date:** January 2025
**Status:** Completed

**What was done:**
- Created WatchlistPanel container component with navigation
- Created WatchlistList component showing all watchlists with counts
- Created WatchlistDetail component for viewing/editing watchlists
- Created ImportModal for importing tickers (CSV, JSON, text, TradingView)
- Added ticker autocomplete in watchlist detail (same as screener input)
- Integrated watchlists into App.tsx with tab navigation

**Files Created:**
- `app/src/client/components/watchlist/WatchlistPanel.tsx` - Container with navigation
- `app/src/client/components/watchlist/WatchlistList.tsx` - List of all watchlists
- `app/src/client/components/watchlist/WatchlistDetail.tsx` - Single watchlist view
- `app/src/client/components/watchlist/ImportModal.tsx` - Import modal

**Files Modified:**
- `app/src/client/lib/client.ts` - Added watchlist API functions
- `app/src/client/App.tsx` - Added Watchlists tab, integrated WatchlistPanel

**Key Features:**
- Create, view, edit, delete watchlists
- Add/remove tickers with notes and tags
- Import from multiple formats with live preview
- Export to CSV
- Scan individual tickers or entire watchlists
- Ticker autocomplete when adding to watchlist

**Key Learnings:**
- [!] With `exactOptionalPropertyTypes`, can't pass `undefined` to optional props
  - CORRECT: `...(value && { prop: value })`
  - WRONG: `{ prop: value || undefined }`
- React `key` prop can force component re-mount when loading saved state

---

### Sprint 9: Screener Config Persistence
**Date:** January 2025
**Status:** Completed

---

### Task 9.1-9.3: Saved Screener Configurations
**Date:** January 2025
**Status:** Completed

**What was done:**
- Created ScreenerConfigRepository for managing saved configs
- Added API routes for config CRUD operations
- Created ConfigManager UI component with Save/Load buttons
- Integrated into App.tsx filters section

**Files Created:**
- `app/src/server/db/repositories/screenerConfig.ts` - Config repository
- `app/src/server/routes/screenerConfig.ts` - Config API routes
- `app/src/client/components/ConfigManager.tsx` - Save/Load UI

**Files Modified:**
- `app/src/server/index.ts` - Registered config routes
- `app/src/client/lib/client.ts` - Added config API functions
- `app/src/client/App.tsx` - Integrated ConfigManager, added state tracking
- `app/src/client/components/BasicFilters.tsx` - Added initialFilters prop

**API Endpoints:**
```
GET    /api/configs           - List all configs
GET    /api/configs/:id       - Get single config
POST   /api/configs           - Create config
PUT    /api/configs/:id       - Update config
DELETE /api/configs/:id       - Delete config
POST   /api/configs/:id/duplicate - Duplicate config
```

**Key Learnings:**
- Config data structure: `{ columns: string[], filters: Filter[], orderBy?: OrderBy }`
- Use React `key` prop to force BasicFilters re-mount when loading config
- Track `currentFilters` in App state for saving

---

### Sprint 10: User Preferences
**Date:** January 2025
**Status:** Completed

---

### Task 10.1-10.3: Preferences & Settings
**Date:** January 2025
**Status:** Completed

**What was done:**
- Created PreferencesRepository for key-value settings and favorite fields
- Added API routes for preferences and favorites
- Created Settings tab with preferences UI
- Added favorite fields manager

**Files Created:**
- `app/src/server/db/repositories/preferences.ts` - Preferences repository
- `app/src/server/routes/preferences.ts` - Preferences API routes
- `app/src/client/components/SettingsPanel.tsx` - Settings UI

**Files Modified:**
- `app/src/server/index.ts` - Registered preferences routes
- `app/src/client/lib/client.ts` - Added preferences API functions
- `app/src/client/App.tsx` - Added Settings tab

**API Endpoints:**
```
GET    /api/preferences           - Get all preferences
GET    /api/preferences/:key      - Get single preference
PUT    /api/preferences/:key      - Set preference
DELETE /api/preferences/:key      - Delete preference
POST   /api/preferences/batch     - Set multiple preferences

GET    /api/favorites/fields      - Get favorite fields
POST   /api/favorites/fields      - Add favorite field
DELETE /api/favorites/fields/:name - Remove favorite field
PUT    /api/favorites/fields      - Set all favorite fields
```

**Settings Available:**
- Results per page (25, 50, 100, 200)
- Auto-refresh toggle with interval
- Favorite fields for quick column access

**Tests (165 total):**
- All previous tests still passing
- New repository and route coverage

---

## Backlog / Future Enhancements

### Sector/Industry Filtering (Sprint 4 extension)
**Priority:** High
**Reason:** User wants to filter stocks by category (e.g., technology stocks between $50-$250)

**Implementation:**
- TradingView API supports `sector` and `industry` fields
- Sectors include: Electronic Technology, Technology Services, Consumer Durables, Retail Trade, etc.
- Add multi-select dropdown to BasicFilters component
- Send sector filter to API: `{ field: "sector", op: "in", value: ["Electronic Technology", "Technology Services"] }`

**Data available:** Sector data already in `screener-service/data/tickers.json`


### Hybrid Filtering Approach (Future Enhancement)
**Priority:** Medium
**Reason:** Better UX for specific ticker scans

**Implementation:**
- For small ticker sets (<50): Fetch all data once, then filter client-side (instant filtering)
- For market-wide scans (>50): Use server-side filtering (handles large datasets)
- Could auto-detect based on ticker count or add a toggle

**Benefits:**
- Instant filter/column changes for small scans
- Still handles large market scans efficiently

---

## Sprint 11: Filter-First Market Scanning
**Date:** January 2025
**Status:** Completed

---

### Task 11.1: Filter-First UI Restructure
**Date:** January 2025
**Status:** Completed

**What was done:**
- Restructured UI from ticker-centric to filter-first workflow
- Enhanced MarketSelector with grouped options (US Markets, Global, International)
- Added specific US exchange options: NASDAQ, NYSE, AMEX
- Created QuickFilters component with 8 preset filter buttons
- Added searchable column selector dropdown

**Files Created:**
- `app/src/client/components/QuickFilters.tsx` - Preset filter buttons

**Files Modified:**
- `app/src/client/components/MarketSelector.tsx` - Added grouped options, exchange filters
- `app/src/client/components/ColumnSelector.tsx` - Added search functionality
- `app/src/client/App.tsx` - Integrated QuickFilters, exchange filter handling

**New UI Flow:**
```
1. Select market (required) - dropdown with exchange-specific options
2. Define filters (required) - pill-based filter builder
3. Apply quick filters (optional) - one-click preset buttons
4. Limit to tickers (optional) - autocomplete input
5. Configure columns (optional) - searchable selector
6. Scan - enabled when market + 1 filter
```

**Quick Filter Presets:**
- "Up >5%" - change > 5%
- "Down >5%" - change < -5%
- "High Volume" - volume > 10M
- "Under $10" - close < 10
- "Large Cap" - market_cap > 10B
- "Tech Sector" - sector = Technology
- "Large Cap Tech" - combined preset
- "Penny Stocks" - close < 5

**Key Learnings:**
- Use `<optgroup>` for organized dropdown options
- Exchange filters (NASDAQ/NYSE/AMEX) added as separate filter on scan
- Quick filters merge with existing filters, avoiding duplicates by field

---

### Task 11.2: Performance Optimizations
**Date:** January 2025
**Status:** Completed

**What was done:**
- Created shared `useFields` hook with module-level cache
- Eliminated duplicate `getFields()` API calls (was 2, now 1)
- Added memoization throughout components
- Fixed memory leak in TickerInput blur handler
- Fixed click-outside listener re-registration in FilterBuilder
- Removed `filterKey` anti-pattern from App.tsx

**Files Created:**
- `app/src/client/hooks/useFields.ts` - Shared fields cache hook

**Files Modified:**
- `app/src/client/App.tsx` - Removed filterKey, fixed inline callback, extracted helpers
- `app/src/client/components/FilterBuilder.tsx` - Uses shared hook, memoization
- `app/src/client/components/ColumnSelector.tsx` - Uses shared hook, O(1) lookups
- `app/src/client/components/TickerInput.tsx` - Blur timeout cleanup

**Performance Improvements:**

| Issue | Fix | Impact |
|-------|-----|--------|
| Duplicate getFields() calls | Shared `useFields` hook with module cache | 1 API call instead of 2 |
| Inline callback defeating memo | Use existing `handleColumnsChange` | ResultsTable memo works |
| Missing memoization | Added `useMemo` to fieldsByCategory, displayFields, filteredFields | O(n) → O(1) on re-renders |
| Click-outside listener churn | Empty dependency array, use refs | Listener registered once |
| Blur timeout memory leak | Track with ref, cleanup on unmount | No state updates on unmounted |
| filterKey forcing re-renders | Removed entirely | No unnecessary re-mounts |

**Key Learnings:**
- [!] Module-level cache pattern for shared data:
  ```typescript
  let cache: Data | null = null;
  let fetchPromise: Promise<Data> | null = null;

  export function useSharedData() {
    // Return cached data immediately if available
    // Otherwise wait for single in-flight request
  }
  ```
- [!] Click-outside listeners should use refs, not state in dependencies
- [!] Inline callbacks in JSX defeat `memo()` optimization
- Use `Map` instead of `array.find()` for O(1) lookups in render loops

**Tests:**
- Build succeeds with all changes
- Pre-existing test failures unrelated to changes (TickerInput tests expect "Scanning..." but component shows "Processing...")

---

### Task 11.3: K/M/B/T Input for Large Numbers
**Date:** January 2025
**Status:** Completed

**What was done:**
- Added parsing support for K/M/B/T suffixes in market cap filter input
- Added formatting for "between" operator to show formatted values
- Market cap values stored as raw USD (not abbreviated)

**Files Modified:**
- `app/src/client/components/FilterBuilder.tsx` - Added `parseNumberWithSuffix()` and `formatLargeNumber()`

**Number Parsing:**
```typescript
// Input: "10B" → 10000000000
// Input: "1.5M" → 1500000
// Input: "500K" → 500000
parseNumberWithSuffix("10B") // → 10000000000
```

---

### Task 11.4: Pagination
**Date:** January 2025
**Status:** Completed

**What was done:**
- Created Pagination component with prev/next buttons and page numbers
- Added offset parameter support to useScreener hook
- Integrated pagination state into App.tsx
- Pagination resets to page 1 when filters/market/tickers change
- Loads resultsPerPage from user preferences (default 50)

**Files Created:**
- `app/src/client/components/Pagination.tsx` - Pagination controls

**Files Modified:**
- `app/src/client/hooks/useScreener.ts` - Added offset support
- `app/src/client/lib/client.ts` - Added offset to ScanOptions
- `app/src/client/App.tsx` - Integrated pagination state and controls

**Pagination Features:**
- Shows "Showing X - Y of Z results" info
- Shows page numbers with ellipsis for large page counts
- Prev/Next buttons with disabled states
- Current page highlighted
- Loads resultsPerPage from preferences API

**Key Learnings:**
- [!] With `exactOptionalPropertyTypes`, use spread syntax to conditionally include props:
  ```typescript
  // CORRECT:
  const options = {
    markets,
    filters,
    ...(limitTickers.length > 0 && { tickers: limitTickers }),
    ...(offset !== undefined && { offset }),
  };

  // WRONG (causes type error):
  const options = {
    tickers: limitTickers.length > 0 ? limitTickers : undefined,
  };
  ```
- Page changes trigger new API calls with calculated offset: `(page - 1) * resultsPerPage`
- Reset page to 1 whenever filters/market/tickers change

---

### Task 11.5: Dark Mode
**Date:** January 2025
**Status:** Completed

**What was done:**
- Added dark mode toggle slider in header (top right)
- Configured Tailwind for class-based dark mode
- Created useTheme hook with localStorage persistence
- Applied dark mode classes to all major components
- System preference detection for initial theme

**Files Created:**
- `app/src/client/hooks/useTheme.ts` - Theme state management with persistence
- `app/src/client/components/ThemeToggle.tsx` - Toggle slider with sun/moon icons

**Files Modified:**
- `app/tailwind.config.js` - Added `darkMode: "class"`
- `app/src/client/App.tsx` - Added theme toggle to header, dark mode classes to all panels
- `app/src/client/components/ResultsTable.tsx` - Dark mode for table
- `app/src/client/components/Pagination.tsx` - Dark mode for pagination controls
- `app/src/client/components/FilterBuilder.tsx` - Dark mode for filter pills and popups

**Dark Mode Implementation:**
- Toggle in header (top right) with sliding knob animation
- Theme persists to localStorage (`theme` key)
- Detects system preference on first visit
- All panels: `bg-white dark:bg-gray-800`
- All borders: `border-gray-200 dark:border-gray-700`
- All text: `text-gray-700 dark:text-gray-300`
- Positive/negative colors adjusted for dark backgrounds

**Key Learnings:**
- Tailwind `darkMode: "class"` allows manual toggle control
- Apply `dark` class to `document.documentElement` (html element)
- Use `prefers-color-scheme` media query for system preference detection
- Keep color contrast high in dark mode (use lighter shades like gray-300 instead of gray-500)
- [!] Tailwind's `:is(.dark *)` selectors may require explicit light mode CSS overrides:
  ```css
  /* Light mode must use !important to override Tailwind dark styles */
  html.light body,
  html:not(.dark) body {
    background-color: #f3f4f6 !important;
  }
  ```
- Apply theme immediately on module load (before React mounts) to prevent flash

