# TV Screener+ Progress Log

This file tracks learnings, decisions, and important notes from each completed task.
It serves as institutional knowledge for anyone continuing work on this codebase.

Last Updated: January 2025

---

## How to Read This File

- Entries are appended chronologically (newest at bottom)
- Each entry includes: Task ID, Date, Key Learnings
- Search for specific topics using Ctrl+F
- Critical warnings marked with [!]

---

## Project Setup

### Initial Planning (January 2025)

**Decisions Made:**
- Architecture: Python (FastAPI) + TypeScript (Fastify/React) hybrid
- Database: SQLite with better-sqlite3 (added in Phase B, not MVP)
- MVP approach: In-memory first, persistence later
- Development: Direct (no Docker), hot-reload enabled

**Key Documents (in `docs/`):**
- `spec_v2.md` - Full specification with all requirements
- `tv-screener-implementation-plan.md` - Sprint-by-sprint implementation plan
- `progress.txt` - This file (append-only learning log)
- `planner.md` - Planning agent template (reference)

**Workflow:**
- PLAN MODE: Discuss approach before coding
- BUILD MODE: Implement after agreement
- Tests written per task

---

## Sprint Progress

(Entries will be appended below as tasks are completed)

---

### Task 1.1: Initialize Project Structure
**Date:** January 2025
**Status:** Completed

**What was done:**
- Created monorepo folder structure: `screener-service/`, `app/`, `docs/`
- Moved all spec/planning files to `docs/` folder
- Created `AGENTS.md` at root with instructions for AI agents
- Created `.gitignore` for Python + Node.js artifacts

**Key Learnings:**
- Keep documentation centralized in `docs/` for easy discovery
- `AGENTS.md` ensures any AI agent reads specs before making changes
- Empty placeholder files (`__init__.py`, `requirements.txt`, `package.json`) help establish structure

**File Locations:**
- Specs and plans: `docs/`
- Python service: `screener-service/src/`
- TypeScript backend: `app/src/server/`
- React frontend: `app/src/client/`

---

### Task 1.2: Implement Python Health Endpoint
**Date:** January 2025
**Status:** Completed

**What was done:**
- Set up devenv at project root (Python 3.11 + Node 20)
- Created FastAPI application with health endpoint
- Added pytest tests for health endpoint

**Files Created:**
- `devenv.nix` - Nix-based dev environment (Python + Node)
- `devenv.yaml` - devenv configuration
- `.envrc` - direnv auto-activation
- `screener-service/src/config.py` - Settings with pydantic-settings
- `screener-service/src/main.py` - FastAPI app entry point
- `screener-service/src/routes.py` - /health endpoint
- `screener-service/tests/test_health.py` - Endpoint tests
- `screener-service/pytest.ini` - Pytest configuration

**Key Learnings:**
- devenv.nix at project root provides unified dev environment for Python + Node
- Use `pydantic-settings` for type-safe configuration from env vars
- FastAPI test client uses `httpx.AsyncClient` with `ASGITransport`
- [!] Remember to add `sys.path` manipulation in tests to import from `src/`

**How to Run:**
```bash
# Enter devenv shell (auto-activates with direnv)
devenv shell

# Or manually:
cd screener-service
pip install -r requirements.txt
python src/main.py

# Run tests:
cd screener-service
pytest
```

**Endpoints:**
- `GET /health` - Returns `{"status": "ok", "timestamp": "..."}`

---

### Task 1.3: Implement /scan Endpoint with tradingview-screener
**Date:** January 2025
**Status:** Completed

**What was done:**
- Created Pydantic models for scan request/response schemas
- Implemented ScreenerService wrapper for tradingview-screener library
- Added /scan endpoint with filter, ordering, pagination support
- Created comprehensive tests with real TradingView API calls

**Files Created/Modified:**
- `screener-service/src/models.py` - Request/response Pydantic models
- `screener-service/src/screener.py` - tradingview-screener wrapper
- `screener-service/src/routes.py` - Added /scan endpoint
- `screener-service/tests/test_scan.py` - Scan endpoint tests (8 tests)
- `screener-service/requirements.txt` - Added tradingview-screener dependency

**Key Learnings:**
- [!] tradingview-screener Column class uses Python comparison operators, NOT methods:
  - CORRECT: `col > value`, `col >= value`, `col == value`
  - WRONG: `col.above(value)`, `col.below(value)`, `col.equal(value)`

- [!] Multiple filters MUST use `where2(And(...))`, NOT chained `.where()` calls:
  - CORRECT: `query.where2(And(condition1, condition2, condition3))`
  - WRONG: `query.where(cond1).where(cond2).where(cond3)` (only applies last filter!)

- Single filter can use `query.where(condition)` directly

- Column methods available: `.between(low, high)`, `.not_between()`, `.isin([])`, `.not_in([])`

- Response fields use aliases for camelCase JSON (e.g., `total_count` â†’ `totalCount`)

**Filter Operators Supported:**
- Comparison: `gt`, `gte`, `lt`, `lte`, `eq`, `neq`
- Range: `between`, `not_between` (require list of 2 values)
- Set: `in`, `not_in` (require list of values)

**Endpoints:**
- `POST /scan` - Execute screener scan
  - Request: `{columns: [...], filters?: [...], orderBy?: {...}, limit?: 50, offset?: 0}`
  - Response: `{totalCount, results, timestamp, durationMs}`

**Tests (8 total, all passing):**
1. `test_scan_basic_columns` - Basic column selection
2. `test_scan_with_filter_gt` - Greater-than filter
3. `test_scan_with_filter_between` - Between filter
4. `test_scan_with_ordering` - Order by field
5. `test_scan_with_multiple_filters` - Multiple filters combined
6. `test_scan_empty_columns_rejected` - Validation error on empty columns
7. `test_scan_invalid_between_value` - Validation error on bad between value
8. `test_scan_response_timing` - Response includes timing metadata

---

### Sprint 2: TypeScript Backend Setup
**Date:** January 2025
**Status:** Completed

---

### Task 2.1: Initialize TypeScript/Fastify Project
**Date:** January 2025
**Status:** Completed

**What was done:**
- Set up Node.js project with TypeScript, Fastify, and strict type checking
- Created Fastify server with CORS for local development
- Added health endpoint at /api/health

**Files Created:**
- `app/package.json` - Project dependencies (fastify, @fastify/cors, tsx, vitest)
- `app/tsconfig.json` - Strict TypeScript configuration
- `app/tsconfig.server.json` - Server-specific build config
- `app/vitest.config.ts` - Vitest test configuration
- `app/src/server/index.ts` - Fastify server entry point
- `app/src/server/config.ts` - Configuration from environment variables
- `app/tests/health.test.ts` - Health endpoint tests

**Key Learnings:**
- [!] With `noPropertyAccessFromIndexSignature`, must use bracket notation for process.env:
  - CORRECT: `process.env["APP_PORT"]`
  - WRONG: `process.env.APP_PORT`

- Strict TypeScript settings enabled:
  - `noImplicitAny`, `strictNullChecks`, `strictFunctionTypes`
  - `noUnusedLocals`, `noUnusedParameters`
  - `exactOptionalPropertyTypes`, `noImplicitReturns`
  - `noUncheckedIndexedAccess`, `noPropertyAccessFromIndexSignature`

- tsx (via `tsx watch`) provides fast TypeScript execution without compilation step

**How to Run:**
```bash
cd app
npm install
npm run dev:server  # Starts on port 3000
npm test            # Run tests
```

---

### Task 2.2: Create Screener Client Service
**Date:** January 2025
**Status:** Completed

**What was done:**
- Created TypeScript types matching Python API models
- Implemented ScreenerClient class using ofetch for HTTP calls
- Added custom ScreenerServiceError for proper error handling

**Files Created:**
- `app/src/server/types/screener.ts` - TypeScript types for API
- `app/src/server/services/screenerClient.ts` - HTTP client for Python service
- `app/tests/screenerClient.test.ts` - Client integration tests (6 tests)

**Key Learnings:**
- ofetch provides clean async HTTP with automatic JSON parsing
- Custom error class (ScreenerServiceError) preserves HTTP status codes and details
- Type assertions needed for indexed access with `noUncheckedIndexedAccess`

**TypeScript Types:**
```typescript
interface ScanRequest {
  markets?: string[];
  columns: string[];
  filters?: Filter[];
  orderBy?: OrderBy;
  limit?: number;
  offset?: number;
}

interface ScanResponse {
  totalCount: number;
  results: Record<string, unknown>[];
  timestamp: string;
  durationMs: number;
}
```

---

### Task 2.3: Create Proxy Routes
**Date:** January 2025
**Status:** Completed

**What was done:**
- Created Fastify routes that proxy to Python service
- Added error handling that forwards Python errors with correct status codes
- Registered routes in main server file

**Files Created/Modified:**
- `app/src/server/routes/screener.ts` - Screener proxy routes
- `app/src/server/index.ts` - Added route registration
- `app/tests/routes.test.ts` - Route integration tests (5 tests)

**Endpoints:**
- `POST /api/scan` - Proxy to Python /scan
- `GET /api/screener/health` - Proxy to Python /health
- `GET /api/health` - Node.js service health (direct)

**Key Learnings:**
- Fastify routes use async/await pattern naturally
- Error responses must explicitly return reply to satisfy type checker
- Integration tests require both Python and Node services running

**Tests (13 total across Sprint 2):**
- health.test.ts: 2 tests (Node health endpoint)
- screenerClient.test.ts: 6 tests (Python API client)
- routes.test.ts: 5 tests (Proxy route integration)

---
